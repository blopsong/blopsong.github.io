<meta charset="UTF-8">
<p>+++ title = &#8217;Csapp&#8217; date = 2024-10-02T10:08:17+08:00 draft = true +++</p>

<blockquote>
<p>Notice that our hello program calls the printf function, which is part of the standard C library provided by every C compiler. The printf function resides in a separate precompiled object file called printf.o, which must somehow be merged with our hello.o program. The linker (ld) handles this merging. The result is the hello file, which is an executable object file (or simply executable) that is ready to be loaded into memory and executed by the system.</p>
</blockquote>

<p>So does this mean that the standar library is inside the C compiler? Does that applies to other programming languages? I used to wonder where would the operating system find out the standar library. Might this be the answer?</p>

<blockquote>
<p>These instructions copy the bytes in the hello, world\n string from memory to the register file, and from there to the display device, where they are displayed on the screen.</p>
</blockquote>

<p>Why is there <strong>registers</strong>? Can we replace it with <strong>memory</strong>?</p>

<blockquote>
<p>When a program such a shell oruns on a modern system, the operating system provides the illusion that the program is the only one running on the system. The program appears to have exclusive use of both the processor, main memory, andI/O devices. The processor appears to execute the instructions in the program, one after the other, without interruption. And the code and data of the program appear to be the only objects in the system’s memory. These illusions are provided by the notion of a process, one of the most important and successful ideas in computer science.</p>
</blockquote>

<p>I didn&#8217;t know the <em>exclusiveness</em> before.</p>

<blockquote>
<p>Virtual memory is an abstraction that provides each process with the illusion that it has exclusive use of the main memory. Each process has the same uniform view of memory, which is known as its virtual address space.</p>
</blockquote>

<p>Here is fake <em>exclusiveness</em> too.</p>

<blockquote>
<p>For virtual memory to work, a sophisticated interaction is required between the hardware and the operating system software, including a hardware translation of every address generated by the processor. The basic idea is to store the contents of a process’s virtual memory on disk and then use the main memory as a cache for the disk</p>
</blockquote>

<p>I just know it for the first time.</p>

<h6 id='two_kinds_of_right_shift'>Two kinds of <strong>right shift</strong></h6>

<pre><code>- Logical. A logical right shift fills the left end with k zeros, giving a result [0, . . . , 0, x w−1, x w−2, . . . x k].</code></pre>

<pre><code>- Arithmetic. An arithmetic right shift fills the left end with k repetitions of the most significant bit, giving a result [x w−1, . . . , xw−1, xw−1, xw−2, . . . x k]. This convention might seem peculiar, but as we will see, it is useful for operating on signed integer data.</code></pre>

<p>I think there is only logical <strong>left shift</strong>? Why is that?</p>

<blockquote>
<p>The C standards do not precisely define which type of right shift should be used with signed numbers—either arithmetic or logical shifts may be used. This unfortunately means that any code assuming one form or the other will potentially encounter portability problems. In practice, however, almost all compiler/machine combinations use arithmetic right shifts for signed data, and many programmers assume this to be the case. For unsigned data, on the other hand, right shifts must be logical. In contrast to C, Java has a precise definition of how right shifts should be performed. The expression x &gt;&gt; k shifts x arithmetically by k positions, while x &gt;&gt;&gt; k shifts it logically.</p>

<p>For a data type consisting of w bits, what should be the effect of shifting by some value k ≥ w? The C standards carefully avoid stating what should be done in such a case. On many machines, the shift instructions consider only the lower log 2 w bits of the shift amount when shifting a w-bit value, and so the shift amount is computed as k mod w.</p>

<p>Some possibly nonintuitive behavior arises due to C’s handling of expressions containing combinations of signed and unsigned quantities. When an op-eration is performed where one operand is signed and the other is unsigned, C implicitly casts the signed argument to unsigned and performs the operations assuming the numbers are nonnegative. As we will see, this convention makes little difference for standard arithmetic operations, but it leads to nonintuitive results for relational operators such as &lt; and &gt;. Consider the comparison -1 &lt; 0U. Since the second operand is unsigned, the first one is implicitly cast to unsigned, and hence the expression is equivalent to the comparison 4294967295U &lt; 0U (recall that T2Uw (−1) = UMaxw), which of course is false.</p>
</blockquote>

<h3 id='chapter_3'>Chapter 3</h3>

<h6 id='data_formats'>Data Formats</h6>

<p>Due to its origins as a 16-bit architecture that expanded into a 32-bit one, Intel uses the term “word” to refer to a 16-bit data type. Based on this, they refer to 32- bit quantities as “double words,” and 64-bit quantities as “quad words.” Figure 3.1 shows the x86-64 representations used for the primitive data types of C. Standard int values are stored as double words (32 bits). Pointers (shown here as char *) are stored as 8-byte quad words, as would be expected in a 64-bit machine. With x86-64, data type long is implemented with 64 bits, allowing a very wide range of values.</p>

<p>| C declaration | Intel data type | Assembly-code suffix | Size (bytes) | | ------------- | --------------- | -------------------- | ------------ | | char      | Byte       | b | 1 | | short   |  Word       | w | 2 | | int | Double word | l | 4 | | long | Quad word | q | 8 | | char * | Quad word | q | 8 | | float | Single precision | s | 4 | | double | Double precision | l | 8 |</p>

<p><strong>Figure 3.1</strong> Sizes of C data types in x86-64. With a 64-bit machine, pointers are 8 bytes long.</p>

<p>Floating-point numbers come in two principal formats: single-precision (4 byte) values, corresponding to C data type float, and double-precision (8-byte) values, corresponding to C data type double.</p>

<p>An x86-64 central processing unit (CPU) contains a set of 16 general-purpose registers storing 64-bit values. These registers are used to store integer data as well as pointers. Figure 3.2 diagrams the 16 registers. Their names all begin with %r, but otherwise follow multiple different naming conventions, owing to the historical evolution of the instruction set. The original 8086 had eight 16-bit registers, shown in Figure 3.2 as registers %ax through %bp. Each had a specific purpose, and hence they were given names that reflected how they were to be used. With the extension to IA32, these registers were expanded to 32-bit registers, labeled %eax through %ebp. In the extension to x86-64, the original eight registers were expanded to 64 bits, labeled %rax through %rbp. In addition, eight new registers were added, and these were given labels according to a new naming convention: %r8 through %r15.</p>

<p>| 64 bits | 32 b | 16 b | 8b | role | |-|-|-|-|-| | %rax | %eax | %ax | %al | return value | | %rbx | %ebx | %bx | %bl | callee saved | | %rcx | %ecx | %cx | %cl | 4th argument | | %rdx | %edx | %dx | %dl | 3rd argument | | %rsi | %esi | %si | %sil | 2nd argument | | %rdi | %edi | %di | %dil | 1st argument | | %rbp | %ebp | %bp | %bpl | callee saved | | %rsp | %esp | %sp | %spl | stack pointer |</p>

<p><strong>Figure 3.2</strong> Integer registers. The low-order portions of all 16 registers can be accessed as byte, word (16-bit), double word (32-bit), and quad word (64-bit) quantities.</p>

<h6 id='operand_specifiers'>Operand Specifiers</h6>

<blockquote>
<p>Thus, the different operand possibilities can be classified into three types. The first type, immediate, is for constant values. In ATT- format assembly code, these are written with a ‘$’ followed by an integer using standard C notation—for example, $-577 or $0x1F. Different instructions allow different ranges of immediate values; the assembler will automatically select the most compact way of encoding a value. The second type, register, denotes the contents of a register, one of the sixteen 8-, 4-, 2-, or 1-byte low-order portions of the registers for operands having 64, 32, 16, or 8 bits, respectively. In Figure 3.3, we use the notation ra to denote an arbitrary register a and indicate its value with the reference R[ra], viewing the set of registers as an array R indexed by register identifiers. The third type of operand is a memory reference, in which we access some memory location according to a computed address, often called the effective ad- dress. Since we view the memory as a large array of bytes, we use the notation Mb[Addr] to denote a reference to the b-byte value stored in memory starting at address Addr. To simplify things, we will generally drop the subscript b.</p>
</blockquote>

<p>TODO!()</p>

<p><strong>Figure 3.3</strong> Operand forms. Operands can denote immediate (constant) values, register values, or values from memory. The scaling factor s must be either 1, 2, 4, or 8</p>

<h6 id='data_movement_instruction'>Data Movement Instruction</h6>

<blockquote>
<p>The source operand desinates a value that is immediate, stored in a register, or stored in memory. The destination operand designates a location that is either a register or a memory address. x86-64 imposes the restriction that a move instruction cannot have both operands refer to memory locations.  Copying a value from one memory location to another requires two instructions—the first to load the source value into a register, and the second to write this register value to the destination. Referring to Figure 3.2, register operands for these instructions can be the labeled portions of any of the 16 registers, where the size of the register must match the size designated by the last character of the instruction (‘b’, ‘w’, ‘l’, or ‘q’). For most cases, the mov instructions will only update the specific register bytes or memory locations indicated by the destination operand. The only exception is that when <code>movl</code> has a register as the destination, it will also set the high-order 4 bytes of the register to 0. This exception arises from the convention, adopted in x86-64, that any instruction that generates a 32-bit value for a register also sets the high-order portion of the register to 0.</p>

<p>The regular <code>movq</code> instruction can only have immediate source operands that can be represented as 32-bit two’s-complement numbers. This value is then sign extended to produce the 64-bit value for the destination. The movabsq in-struction can have an arbitrary 64-bit immediate value as its source operand and can only have a register as a destination.</p>
</blockquote>

<p>| Instruction | Effect | Description | |-|-|-| | mov S, D | D &lt;- S | Move | | movb |        | Move byte | | movw |        | Move word | | movl |        | Move double word | | movq |        | Move quad word | | movabsq I, R|  R &lt;- I | Move absolute quad word |</p>

<p><strong>Figure 3.4</strong> Simple data movement instructions</p>

<p>| Instruction | Effect | Description | |-|-|-| | movz S, R | R &lt;- ZeroExtend(S) | Move with zero extension | | movzbw |        | Move with zero-extended byte to word | | movzbl |        | Move with zero-extended byte to double word | | movzwl |        | Move with zero-extended word to double word| | movzbq |        | Move with zero-extended byte to quad word | | movzwq |        | Move with zero-extended word to quad word |</p>

<p><strong>Figure 3.5</strong> Zero-extending data movement instructions. These instructions have a register or memory location as the source and a register as the destination</p>

<p>| Instruction | Effect | Description | |-|-|-| | movs S, R | R &lt;- SignExtend(S) | Move with sign extension | | movsbw |        | Move with sign-extended byte to word | | movsbl |        | Move with sign-extended byte to double word | | movswl |        | Move with sign-extended word to double word| | movsbq |        | Move with sign-extended byte to quad word | | movswq |        | Move with sign-extended word to quad word | | movslq |        | Move with sign-extended double word to quad word | | cltq | %rax &lt;- SignExtend(%eax) | Sign-extended %eax to %rax |</p>

<p><strong>Figure 3.6</strong>  Sign-extending data movement instructions. The movs instructions have a register or memory location as the source and a register as the destination. The <code>cltq</code> instruction is specific to registers %eax and %rax</p>

<p>| Instruction | Effect | Description | |-|-|-| | pushq S | R[%rsp] &lt;- R[%rsp]-8; | Push quad word | |         | M[R[%rsp]] &lt;- S       |                | | popq D  | D &lt;- M[R[%rsp]];      | Pop quad word  | |         | R[%rsp] &lt;- R[%rsp]+8  |                |</p>

<p><strong>Figure 3.8</strong> Push and pop instructions.</p>

<p>| Instruction | Effect | Description | |-|-|-| | leaq S, D | D &lt;- &amp;S | load effective address | |inc D | D ← D+1 | Increment | |dec D | D ← D−1 | Decrement | |neg D | D ← -D | Negate |not D | D ← ~D | Complement |add S, D | D ← D + S | Add |sub S, D | D ← D − S | Subtract |imul S, D | D ← D ∗ S | Multiply |xor S, D | D ← D ^ S | Exclusive-or |or S, D | D ← D \| S | Or | |and S, D | D ← D &amp; S | And |sal k, D | D ← D &lt;&lt; k | Left shift |shl k, D | D ← D &lt;&lt; k | Left shift (same as sal) |sar k, D | D ← D &gt;&gt; A k | Arithmetic right shift |shr k, D | D ← D &gt;&gt; L k | Logical right shift</p>

<p><strong>Figure</strong> 3.10 Integer arithmetic operations. The load effective address (leaq) instruction is commonly used to perform simple arithmetic. The remaining ones are more standard unary or binary operations. We use the notation &gt;&gt;A and &gt;&gt;L to denote arithmetic and logical right shift, respectively. Note the nonintuitive ordering of the operands with ATT-format assembly code.</p>

<h4 id='control'>Control</h4>

<h5 id='condition_codes'>Condition codes</h5>

<p>In addition to the integer registers, the CPU maintains a set of single-bit condition code registers describing attributes of the most recent arithmetic or logical operation. These registers can then be tested to perform conditional branches. These condition codes are the most useful:</p>

<ul>
<li>CF: Carry flag. The most recent operation generated a carry out of the most significant bit. Used to detect overflow for unsigned operations.</li>

<li>ZF: Zero flag. The most recent operation yielded zero.</li>

<li>SF: Sign flag. The most recent operation yielded a negative value.</li>

<li>OF: Overflow flag. The most recent operation caused a two’s-complement overflow—either negative or positive.</li>
</ul>

<p>For example, suppose we used one of the add instructions to perform the equivalent of the C assignment t = a+b, where variables a, b, and t are integers. Then the condition codes would be set according to the following C expressions:</p>

<ul>
<li>CF (unsigned) t &lt; (unsigned) a Unsigned overflow</li>

<li>ZF (t == 0) Zero</li>

<li>SF (t &lt; 0) Negative</li>

<li>OF (a &lt; 0 == b &lt; 0) &amp;&amp; (t &lt; 0 != a &lt; 0) Signed overflow</li>
</ul>

<p>The <code>leaq</code> instruction does not alter any condition codes, since it is intended to be used in address computations. | Instruction | Based on  | Description | |-|-|-| | cmp S1, S2 | S2 − S1 | Compare | | test S1, S2 | S1 &amp; S2 | Test |</p>

<h5 id='accessing_the_condition_codes'>Accessing the Condition Codes</h5>

<p>| Instruction | Synonym | Effect | Set condition | |-|-|-|-| | sete D | setz | D ← ZF | Equal / zero | | setne D | setnz | D ← ~ ZF | Not equal / not zero | | sets D | | D ← SF | Negative | | setns D | |  D ← ~ SF | Nonnegative | | setg D | setnle | D ← ~ (SF ^ OF) &amp; ~ZF | Greater (signed &gt;) | | setge D | setnl | D ← ~ (SF ^ OF) | Greater or equal (signed &gt;=) | | setl D | setnge | D ← SF ^ OF | Less (signed &lt;) | | setle D | setng | D ← (SF ^ OF) \| ZF | Less or equal (signed &lt;=) | | seta D | setnbe | D ← ~ CF &amp; ~ZF | Above (unsigned &gt;) | | setae D | setnb | D ← ~ CF | Above or equal (unsigned &gt;=) | | setb D | setnae | D ← CF | Below (unsigned &lt;) | | setbe D | setna | D ← CF \| ZF | Below or equal (unsigned &lt;=) |</p>

<p><strong>Figure 3.14</strong> The set instructions. Each instruction sets a single byte to 0 or 1 based on some combination of the condition codes. Some instructions have “synonyms,” that is, alternate names for the same machine instruction.</p>

<h5 id='jump_instructions'>Jump Instructions</h5>

<p>!TODO()</p>

<p><strong>Figure 3.15</strong> The jump instructions. These instructions jump to a labeled destination when the jump condition holds. Some instructions have “synonyms,” alternate names for the same machine instruction.</p>

<h5 id='jump_instructions_encodings'>Jump Instructions Encodings</h5>

<p>There are several different encodings for jumps, but some of the most commonly used ones are PC relative. That is, they encode the difference between the address of the target instruction and the address of the instruction immediately following the jump. These offsets can be encoded using 1, 2, or 4 bytes. A second encoding method is to give an “absolute” address, using 4 bytes to directly specify the target. The assembler and linker select the appropriate encodings of the jump destinations.</p>

<h5 id='implementing_conditional_branches_with_conditional_control'>Implementing Conditional Branches with Conditional Control</h5>

<pre><code>if (test-expr)
    then-statement
else
    else-statement</code></pre>

<h5 id='implementing_conditional_branches_with_conditional_moves'>Implementing Conditional Branches with Conditional Moves</h5>

<p>The conventional way to implement conditional operations is through a conditional transfer of control, where the program follows one execution path when a condition holds and another when it does not. This mechanism is simple and general, but it can be very <strong>inefficient</strong> on modern processors.</p>

<pre><code>// (a) Original C code
long absdiff(long x, long y)
{
    long result;
    if (x &lt; y)
        result = y - x;
    else
        result = x - y;
    return result;
}</code></pre>

<pre><code>// (b) Implementation using conditional assignment
long cmovdiff(long x, long y)
{
    long rval = y-x;
    long eval = x-y;
    long ntest = x &gt;= y;
    /* Line below requires single instruction: */
    if (ntest)
        rval = eval; // assembly: cmovge %rdx, %rax
    return rval;
}</code></pre>

<p>!TODO()</p>

<p><strong>Figure 3.18</strong> The conditional move instructions. These instructions copy the source value S to its destination R when the move condition holds. Some instructions have “synonyms,” alternate names for the same machine instruction.</p>

<p>Not all conditional expressions can be compiled using conditional moves. Most significantly, the abstract code we have shown evaluates both then-expr and else-expr regardless of the test outcome. If one of those two expressions could possibly generate an error condition or a side effect, this could lead to invalid behavior. Such is the case for our earlier example (Figure 3.16). Indeed, we put the side effects into this example specifically to force gcc to implement this function using conditional transfers.</p>

<p>As a second illustration, consider the following C function:</p>

<pre><code>long cread(long *xp) {
    return (xp ? *xp : 0);
}</code></pre>

<p>At first, this seems like a good candidate to compile using a conditional move to set the result to zero when the pointer is null, as shown in the following assembly</p>

<p>code:</p>

<pre><code>// long cread(long *xp)
// Invalid implementation of function cread
// xp in register %rdi
1 cread:
2 movq (%rdi), %rax // v = *xp
3 testq %rdi, %rdi // Test x
4 movl $0, %edx Set // ve = 0
5 cmove %rdx, %rax // If x==0, v = ve
6 ret Return // v</code></pre>

<h5 id='loops'>Loops</h5>

<p>Key word, the <code>goto</code> action, C version of assembly <code>jump</code> instruciton.</p>

<h5 id='do_while_loops'>Do while loops</h5>

<h5 id='while_loops'>While loops</h5>

<p>There are a number of ways to translate a while loop into machine code, two of which are used in code generated by gcc.</p>

<p>The first translation method, which we refer to as jump to middle, performs the initial test by performing an unconditional jump to the test at the end of the loop. It can be expressed by the following template for translating from the general while loop form to goto code:</p>

<pre><code>    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;</code></pre>

<p>The second translation method, which we refer to as guarded do, first trans- forms the code into a do-while loop by using a conditional branch to skip over the loop if the initial test fails. Gcc follows this strategy when compiling with higher levels of optimization, for example, with command-line option -O1. This method can be expressed by the following template for translating from the general while loop form to a do-while loop:</p>

<pre><code>t = test-expr;
if (!t)
    goto done;
do
    body-statement
    while (test-expr);
done:</code></pre>

<h5 id='for_loops'>For Loops</h5>

<p>Almost the same.</p>

<p>The general form of a <strong>for</strong> loop is as follows:</p>

<pre><code>for (init-expr; test-expr; update-expr)
    body-statement</code></pre>

<p>The C language standard states (with one exception, highlighted in Problem 3.29) that the behavior of such a loop is identical to the following code using a while loop:</p>

<pre><code>init-expr;
while (test-expr) {
    body-statement
    update-expr;
}</code></pre>

<h5 id='switch_statements'>Switch Statements</h5>

<p>Jump tables.</p>

<h4 id='procedure'>Procedure</h4>

<p>Procedures are a key abstraction in software. They provide a way to package code that implements some functionality with a designated set of arguments and an optional return value. This function can then be invoked from different points in a program. Well-designed software uses procedures as an abstraction mechanism, hiding the detailed implementation of some action while providing a clear and concise interface definition of what values will be computed and what effects the procedure will have on the program state. Procedures come in many guises in different programming languages—functions, methods, subroutines, handlers, and so on—but they all share a general set of features.</p>

<p>There are many different attributes that must be handled when providing machine-level support for procedures. For discussion purposes, suppose procedure P calls procedure Q, and Q then executes and returns back to P. These actions involve one or more of the following mechanisms:</p>

<ul>
<li>
<p>Passing control. The program counter must be set to the starting address of the code for Q upon entry and then set to the instruction in P following the call to Q upon return.</p>
</li>

<li>
<p>Passing data. P must be able to provide one or more parameters to Q, and Q must be able to return a value back to P.</p>
</li>

<li>
<p>Allocating and deallocating memory. Q may need to allocate space for local variables when it begins and then free that storage before it returns.</p>
</li>
</ul>

<p>The <strong>runtime stack</strong> (figure 3.25)(notice it is different from the memory layout of the binary executable. It is just the procedure stack).</p>

<p>Where <code>ret</code> return is the address of the next instruction.</p>

<h6 id='local_storage_on_the_stack'>Local Storage on the Stack</h6>

<h6 id='local_storage_in_registers'>Local Storage in Registers</h6>

<p>By convention, registers %rbx, %rbp, and %r12–%r15 are classified as <strong>callee-saved</strong> registers.  All other registers, except for the stack pointer %rsp, are classified as <strong>caller-saved</strong> registers.</p>

<h6 id='recursive_procedures'>Recursive Procedures</h6>

<h5 id='array_allocation_and_access'>Array Allocation and Access</h5>

<h6 id='pointer_arithmic'>Pointer Arithmic</h6>
